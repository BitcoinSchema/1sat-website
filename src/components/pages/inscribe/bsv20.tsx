"use client";

import { API_HOST, FetchStatus, feeRate, toastErrorProps } from "@/constants";
import {
  bsv20Balances,
  chainInfo,
  indexers,
  payPk,
  pendingTxs,
  usdRate,
  utxos,
} from "@/signals/wallet";
import { fundingAddress, ordAddress } from "@/signals/wallet/address";
import { BSV20, Ticker } from "@/types/bsv20";
import { getUtxos } from "@/utils/address";
import { calculateIndexingFee } from "@/utils/bsv20";
import { inscribeUtf8 } from "@/utils/inscribe";
import { P2PKH_FULL_INPUT_SIZE, Payment, Utxo } from "@/utils/js-1sat-ord";
import { computed } from "@preact/signals-react";
import { useSignals } from "@preact/signals-react/runtime";
import "buffer";
import { debounce, head } from "lodash";
import Link from "next/link";
import { useRouter, useSearchParams } from "next/navigation";
import React, { useCallback, useEffect, useMemo, useState } from "react";
import toast, { ErrorIcon } from "react-hot-toast";
import {
  FaCheckCircle,
  FaClock,
  FaExclamationCircle,
  FaExclamationTriangle,
  FaInfoCircle,
} from "react-icons/fa";
import { RiMagicFill, RiSettings2Fill } from "react-icons/ri";
import { useLocalStorage } from "usehooks-ts";
import { InscriptionTab } from "./tabs";

enum ActionType {
	Mint = "mint",
	Deploy = "deploy",
}
interface InscribeBsv20Props {
	inscribedCallback: () => void;
}

const InscribeBsv20: React.FC<InscribeBsv20Props> = ({ inscribedCallback }) => {
	useSignals();
	const router = useRouter();
	const params = useSearchParams();
	// const { tab, tick, op } = params.query as { tab: string; tick: string; op: string };
	const tab = params.get("tab") as InscriptionTab;
	const tick = params.get("tick");
	const op = params.get("op");

	const [preview, setPreview] = useState<string | ArrayBuffer | null>(null);
	const [selectedActionType, setSelectedActionType] = useState<ActionType>(
		ActionType.Mint,
	);
	const [tickerAvailable, setTickerAvailable] = useState<boolean | undefined>(
		undefined,
	);
	const [fetchTickerStatus, setFetchTickerStatus] = useState<FetchStatus>(
		FetchStatus.Idle,
	);
	const [inscribeStatus, setInscribeStatus] = useState<FetchStatus>(
		FetchStatus.Idle,
	);
	const [selectedBsv20, setSelectedBsv20] = useState<Ticker>();
	const [limit, setLimit] = useState<string | undefined>("1337");
	const [maxSupply, setMaxSupply] = useState<string>("21000000");
	const [decimals, setDecimals] = useState<number | undefined>();
	const [amount, setAmount] = useState<string>();
	const [mintError, setMintError] = useState<string>();
	const [showOptionalFields, setShowOptionalFields] = useState<boolean>(false);
	const [iterations, setIterations] = useState<number>(1);
	const [bulkEnabled, setBulkEnabled] = useLocalStorage("bulkEnabled", false);
	const [ticker, setTicker] = useState<string | null>(tick);

	useEffect(() => {
		if (op) {
			setSelectedActionType(op as ActionType);
		}
	}, [selectedActionType, op]);

	useEffect(() => {
		if (tick) {
			setTicker(tick);
		}
	}, [setTicker, tick]);

	const toggleOptionalFields = useCallback(() => {
		setShowOptionalFields(!showOptionalFields);
	}, [showOptionalFields]);

	const changeTicker = useCallback(
		(e: any) => {
			setAmount(undefined);
			setTicker(e.target.value);
			if (mintError) setMintError(undefined);
		},
		[setTicker, mintError, setAmount],
	);

	const checkTicker = useCallback(
		async (tick: string, expectExist: boolean, event?: any) => {
			if (!tick || tick.length === 0) {
				setTickerAvailable(false);
				return;
			}
			try {
				setFetchTickerStatus(FetchStatus.Loading);
				const resp = await fetch(`${API_HOST}/api/bsv20/tick/${tick}`);

				if (resp.status === 200) {
					if (!expectExist) {
						// prevent form from submitting
						event.preventDefault();
						setTickerAvailable(false);
					} else if (expectExist) {
						const bsv20 = (await resp.json()) as Ticker;

						console.log(
							"selected BSV20",
							{ bsv20 },
							parseInt(bsv20.supply!) < parseInt(bsv20.max!),
						);
						setSelectedBsv20(bsv20);
						if (
							!!bsv20 &&
							bsv20.max !== undefined &&
							bsv20.supply !== undefined &&
							parseInt(bsv20.supply) < parseInt(bsv20.max) &&
							bsv20.pendingOps === 0
						) {
							setTickerAvailable(true);
              setAmount(bsv20.lim);
						} else if (bsv20.pendingOps > 0) {
              setTickerAvailable(true);
              setAmount(bsv20.lim);
							setMintError("May be minted out");
						} else {
							setTickerAvailable(false);
							setMintError("Minted Out");
						}
					}
				} else if (resp.status === 404) {
					console.log("ticker not found", tick, "expectExist", expectExist);
					if (expectExist) {
						setTickerAvailable(false);
						setSelectedBsv20(undefined);
					} else {
						setTickerAvailable(true);
					}
				}
				setFetchTickerStatus(FetchStatus.Success);
			} catch (e) {
				console.error({ e });
				setFetchTickerStatus(FetchStatus.Error);
			}
		},
		[setSelectedBsv20, setTickerAvailable, setFetchTickerStatus],
	);

	const changeMaxSupply = useCallback(
		(e: any) => {
			setMaxSupply(e.target.value);
		},
		[setMaxSupply],
	);

	const changeSelectedActionType = useCallback(
		async (e: any) => {
			console.log({ val: e.target.value });
			const actionType = e.target.value.toLowerCase() as ActionType;
			setSelectedActionType(actionType);
			if (ticker) {
				await checkTicker(ticker, actionType === ActionType.Mint);
			}
		},
		[setSelectedActionType, ticker, checkTicker],
	);

	const changeIterations: React.ChangeEventHandler<HTMLInputElement> =
		useCallback((e) => {
			// check the value is not more than the max
			if (parseInt(e.target.value) > parseInt(e.target.max)) {
				toast.error(`Max iterations is ${e.target.max}`);
				return;
			}
			setIterations(parseInt(e.target.value));
		}, []);

	const inSync = computed(() => {
		if (!indexers.value || !chainInfo.value) {
			return false;
		}
		return (
			indexers.value["bsv20-deploy"] >= chainInfo.value?.blocks &&
			indexers.value.bsv20 + 6 >= chainInfo.value?.blocks
		);
	});

	const tickerNote = useMemo(() => {
		return tickerAvailable === false
			? selectedActionType === ActionType.Deploy
				? ticker === ""
					? "¯\\_(ツ)_/¯"
					: "Ticker Unavailable"
				: mintError
			: inSync.value
			  ? selectedBsv20?.pendingOps && selectedBsv20?.pendingOps > 0
					? `${selectedBsv20?.pendingOps} Pending Ops`
					: "1-4 Characters"
			  : selectedActionType === ActionType.Deploy
				  ? "Syncing. May already be deployed."
				  : "Syncing. May be minted out.";
	}, [
		tickerAvailable,
		selectedActionType,
		ticker,
		mintError,
		inSync.value,
		selectedBsv20,
	]);

	const totalTokens = useMemo(() => {
		return iterations * parseInt(amount || "0");
	}, [amount, iterations]);

	// Define the debounced function outside of the render method
	const debouncedCheckTicker = debounce(async (event, expectExist) => {
		await checkTicker(event.target.value, expectExist, event);
	}, 300); // This is a common debounce time. Adjust as needed.

	const changeLimit = useCallback(
		(e: any) => {
			setLimit(e.target.value);
		},
		[setLimit],
	);

	const changeDecimals = useCallback(
		(e: any) => {
			setDecimals(e.target.valuye ? parseInt(e.target.value) : undefined);
		},
		[setDecimals],
	);

	const changeAmount = useCallback(
		(e: any) => {
			if (selectedActionType === ActionType.Mint && selectedBsv20?.lim) {
				if (parseInt(e.target.value) <= parseInt(selectedBsv20.lim)) {
					setAmount(e.target.value);
				}
				return;
			}
			// exclude 0
			if (parseInt(e.target.value) !== 0) {
				setAmount(e.target.value);
			}
		},
		[selectedBsv20, selectedActionType, setAmount],
	);
	// Returns the capped max iterations for a given feature token balance
	const tierMax = useCallback(
		(balance: number, max: number) => {
			const tierNum = calculateTier(balance, bulkMintingTickerMaxSupply);
			if (!amount || tierNum === 0) return 0; // Handle case where balance <= 0

			// Map tier number to max iterations
			const iter = [];
			// tiers as pct of supply
			for (let i = 0; i < 5; i++) {
				let floored = Math.floor(tierThresholds[i] * max);
				console.log({ floored, amount });
				// round to nearest multiple of amount
				if (floored > parseInt(amount) && floored % parseInt(amount) !== 0) {
					floored -= floored % parseInt(amount);
				}

				iter.push(floored);
			}
			const m =
				iter[tierNum - 1] > max ? max : Math.min(iter[tierNum - 1], max);
			if (m < 10) {
				return 10;
			}
			return m;
		},
		[amount],
	);

	const inscribeBsv20 = useCallback(
		async (sortedUtxos: Utxo[]) => {
			if (!ticker || ticker?.length === 0) {
				return;
			}
			setInscribeStatus(FetchStatus.Loading);

			try {
				let inscription = {
					p: "bsv-20",
					op: selectedActionType,
				} as BSV20;

				switch (selectedActionType) {
					case ActionType.Deploy:
						if (parseInt(maxSupply) === 0 || BigInt(maxSupply) > maxMaxSupply) {
							toast.error(
								`Invalid input: please enter a number less than or equal to ${
									maxMaxSupply - BigInt(1)
								}`,
								toastErrorProps,
							);
							return;
						}

						inscription.tick = ticker;
						inscription.max = maxSupply;

						// optional fields
						if (decimals !== undefined) {
							inscription.dec = decimals;
						}
						if (limit) inscription.lim = limit;
						else if (
							!confirm(
								"Warning: Token will have no mint limit. This means all tokens can be minted at once. Are you sure this is what you want?",
							)
						) {
							setInscribeStatus(FetchStatus.Idle);
							return;
						}

						break;
					case ActionType.Mint:
						if (
							!amount ||
							parseInt(amount) == 0 ||
							BigInt(amount) > maxMaxSupply ||
							!selectedBsv20
						) {
							toast.error(
								`Max supply must be a positive integer less than or equal to ${
									maxMaxSupply - BigInt(1)
								}`,
								toastErrorProps,
							);
							return;
						}
						inscription.tick = selectedBsv20.tick;
						inscription.amt = amount;

					default:
						break;
				}

				const text = JSON.stringify(inscription);
				const address = selectedBsv20?.fundAddress;
				const payments: Payment[] = [];
				if (address) {
					payments.push({
						to: address,
						amount: BigInt(iterationFee) * BigInt(iterations),
					});
				}
				const pendingTx = await inscribeUtf8(
					text,
					"application/bsv-20",
					sortedUtxos,
					iterations,
					selectedActionType === ActionType.Deploy
						? ([] as Payment[])
						: payments,
				);

				pendingTxs.value = [pendingTx];
				setInscribeStatus(FetchStatus.Success);
				inscribedCallback();
			} catch (error) {
				setInscribeStatus(FetchStatus.Error);

				toast.error(`Failed to inscribe: ${error}`, toastErrorProps);
				return;
			}
		},
		[
			inscribedCallback,
			amount,
			decimals,
			limit,
			maxSupply,
			selectedActionType,
			selectedBsv20,
			ticker,
			iterations,
		],
	);

	const bulkInscribe = useCallback(async () => {
		if (!payPk || !ordAddress || !fundingAddress.value) {
			return;
		}

		toast.success("Bulk inscribing...");

		// while (iterations > 0) {
		await getUtxos(fundingAddress.value);
		const sortedUtxos = utxos.value?.sort((a, b) =>
			a.satoshis > b.satoshis ? -1 : 1,
		);
		if (!sortedUtxos) {
			console.log("no utxos");
			return;
		}
		// const u = head(sortedUtxos);
		// if (!u) {
		//   console.log("no utxos");
		//   return;
		// }

		await inscribeBsv20(sortedUtxos);
		// setIterations(iterations - 1);
		// sleep for a second
		// await new Promise((resolve) => setTimeout(resolve, 1000));
		// }
	}, [inscribeBsv20]);

	const clickInscribe = useCallback(async () => {
		if (!payPk.value || !ordAddress.value || !fundingAddress.value) {
			return;
		}

		const utxos = await getUtxos(fundingAddress.value);
		const sortedUtxos = utxos.sort((a, b) =>
			a.satoshis > b.satoshis ? -1 : 1,
		);
		const u = head(sortedUtxos);
		if (!u) {
			console.log("no utxo");
			return;
		}

		return await inscribeBsv20([u]);
	}, [inscribeBsv20]);

	useEffect(() => {
		console.log({
			tickerAvailable,
			len: ticker?.length,
			inscribeStatus,
			fetchTickerStatus,
			limit,
			maxSupply,
		});
	}, [
		fetchTickerStatus,
		inscribeStatus,
		limit,
		maxSupply,
		ticker?.length,
		tickerAvailable,
	]);

	const submitDisabled = useMemo(() => {
		return (
			!tickerAvailable ||
			!ticker?.length ||
			inscribeStatus === FetchStatus.Loading ||
			fetchTickerStatus === FetchStatus.Loading ||
			(!!limit && maxSupply < limit)
		);
	}, [
		inscribeStatus,
		tickerAvailable,
		ticker?.length,
		fetchTickerStatus,
		limit,
		maxSupply,
	]);

	const listingFee = useMemo(() => {
		if (!usdRate.value) {
			return minFee;
		}
		return selectedBsv20
			? calculateIndexingFee(usdRate.value)
			: calculateIndexingFee(usdRate.value);
	}, [selectedBsv20]);

	const confirmedOplBalance = useMemo(
		() =>
			bsv20Balances.value?.find(
				(b) => b.tick?.toUpperCase() === bulkMintingTicker,
			)?.all.confirmed,
		[bsv20Balances.value],
	);

	// maxIterations is based on the amount of confirmed OPL the user holds
	const maxIterations = useMemo(() => {
		if (!selectedBsv20) {
			return 0;
		}
		// how much is already minted
		if (!selectedBsv20.supply || !selectedBsv20.max) {
			return 0;
		}
		const supply = parseInt(selectedBsv20.supply);

		if (bulkEnabled && !confirmedOplBalance) {
			toast.error(`You need ${bulkMintingTicker} to bulk mint ${ticker}`);
			return 0;
		}
		const displayOplBalance = confirmedOplBalance
			? selectedBsv20.dec
				? confirmedOplBalance / 10 ** selectedBsv20.dec
				: confirmedOplBalance
			: 0;
		if (!amount || amount === "0") {
			return 0;
		}
		let max = selectedBsv20.max || "0";
		if (!selectedBsv20.max && selectedBsv20.supply) {
			max = selectedBsv20.supply;
		}
		const remainingSupply = parseInt(max) - supply;
		const organicMax = Math.ceil(remainingSupply / parseInt(amount));

		console.log({ organicMax, displayOplBalance });

		return tierMax(displayOplBalance, organicMax);
	}, [selectedBsv20, bulkEnabled, confirmedOplBalance, amount, tierMax]);

	const step = useMemo(() => {
		if (!confirmedOplBalance) {
			return 1;
		}
		// when max iterations is huge we want to increase the step
		// we want to do this proportionally to the max iterations
		return Math.ceil(maxIterations / tierMaxNum(confirmedOplBalance));
	}, [maxIterations, confirmedOplBalance]);

	const spacers = useMemo(
		() => calculateSpacers(maxIterations, step),
		[maxIterations, step],
	);

	const newSupply = useMemo(() => {
		if (
			!totalTokens ||
			selectedBsv20?.supply === undefined ||
			selectedBsv20?.max === undefined ||
			selectedBsv20?.dec === undefined
		) {
			return 0;
		}

		const supply = parseInt(selectedBsv20.supply);
		const max = parseInt(selectedBsv20.max);
		const newTokens = supply / 10 ** selectedBsv20.dec + totalTokens;
		if (newTokens > max) {
			return max;
		}
		return newTokens;
	}, [selectedBsv20, totalTokens]);

	const iterationFeeUsd = useMemo(() => {
		if (!usdRate.value) {
			return 0;
		}
		return ((iterationFee * iterations) / usdRate.value).toFixed(2);
	}, [iterations]);

	const networkFeeUsd = useMemo(() => {
		if (!usdRate.value) {
			return 0;
		}
		return (
			(bytesPerIteration * iterations * feeRate + P2PKH_FULL_INPUT_SIZE * 4) /
			usdRate.value
		).toFixed(2);
	}, [iterations]);

	// confirmedOplBalance && tierMaxNum(confirmedOplBalance) > 0

	const canEnableBulk = useMemo(
		() => (confirmedOplBalance ? confirmedOplBalance > 0 : false),
		[confirmedOplBalance],
	);

	const currentTier = useMemo(() => {
		if (!bsv20Balances.value) {
			return 0;
		}
		const balance = bsv20Balances.value?.find(
			(b) => b.tick?.toUpperCase() === bulkMintingTicker,
		)?.all.confirmed;
		if (!balance) {
			return 0;
		}
		return tierMaxNum(balance);
	}, [bsv20Balances.value]);

	// return the icons depending on tier num
	const stars = useMemo(() => {
		return Array.from({ length: currentTier }, (_, index) => (
			<RiMagicFill key={`balance-star-${index + 1}`} />
		));
	}, [currentTier]);

	const acquireText = useMemo(() => {
		// return Acquire{" "}
		// {/* biome-ignore lint/a11y/useKeyWithClickEvents: <explanation> */}
		// {<span
		//   data-tip={`Tier ${currentTier}/5`}
		//   className="tooltip font-mono text-blue-400 hover:text-blue-500 cursor-pointer"
		//   onClick={() => {
		//     router.push(
		//       `/inscribe?tab=bsv20&tick=${bulkMintingTicker}&op=mint`,
		//     );
		//   }}
		// >
		//   {bulkMintingTicker}
		// </span>}{" "}
		// to enable bulk minting.

		return confirmedOplBalance && tierMaxNum(confirmedOplBalance) > 0
			? `${confirmedOplBalance} ${bulkMintingTicker} available`
			: `Acquire ${bulkMintingTicker} to enable bulk minting`;
	}, [confirmedOplBalance]);

	return (
		<div className="w-full max-w-lg mx-auto">
			<select
				className="text-white w-full p-2 rounded my-2 cursor-pointer"
				value={selectedActionType}
				onChange={changeSelectedActionType}
			>
				<option value={ActionType.Deploy}>Deploy New Ticker</option>
				<option value={ActionType.Mint}>Mint Existing Ticker</option>
			</select>
			<div className="my-2">
				<label className="block mb-4">
					{/* TODO: Autofill */}
					<div className="flex items-center justify-between my-2">
						Ticker{" "}
						{chainInfo.value && indexers.value && (
							<span
								className="text-[#555] hover:text-warning text-sm tooltip transition"
								data-tip={`Latest block: ${chainInfo.value.blocks} BSV20 Deploy: ${indexers.value["bsv20-deploy"]} BSV20 Mint: ${indexers.value.bsv20} ${selectedBsv20?.tick} Pending Ops: ${selectedBsv20?.pendingOps}`}
							>
								{tickerNote}
							</span>
						)}
					</div>
					<div className="relative">
						<input
							className="text-white w-full rounded p-2 uppercase"
							maxLength={4}
							pattern="^\S+$"
							onKeyDown={(event) => {
								if (event.key === " " || event.key === "Enter") {
									event.preventDefault();
									return;
								}
							}}
							value={ticker || ""}
							onChange={(event) => {
								changeTicker(event);
								debouncedCheckTicker(
									event,
									selectedActionType === ActionType.Mint,
								);
							}}
						/>

						{tickerAvailable === true && !inSync.value && (
							<div className="absolute right-0 bottom-0 mb-2 mr-2">
								<FaExclamationTriangle className="w-5 h-5 text-warning" />
							</div>
						)}

						{tickerAvailable === true && inSync.value && (
							<div className="absolute right-0 bottom-0 mb-2 mr-2">
								{selectedBsv20?.included ? (
									<FaCheckCircle className="w-5 h-5 text-success" />
								) : selectedBsv20?.pendingOps &&
								  selectedBsv20?.pendingOps > 0 ? (
									<FaClock className="w-5 h-5 text-warning" />
								) : (
									<FaCheckCircle className="w-5 h-5 text-warning" />
								)}
							</div>
						)}
						{tickerAvailable === false && (
							<div className="absolute right-0 bottom-0 mb-2 mr-2">
								<ErrorIcon />
							</div>
						)}
					</div>
				</label>
			</div>

			{selectedActionType === ActionType.Deploy && (
				<div className="my-2">
					<label className="block mb-4">
						<div className="my-2">Max Supply</div>
						<input
							pattern="\d+"
							type="text"
							className="text-white w-full rounded p-2 uppercase"
							onChange={changeMaxSupply}
							value={maxSupply}
						/>
					</label>
				</div>
			)}

			{selectedActionType === ActionType.Mint && (
				<React.Fragment>
					<div className="my-2">
						<label className="block mb-4">
							<div className="my-2 flex justify-between items-center">
								Amount{" "}
								{selectedBsv20 && (
									<button type="button" className="btn btn-sm">
										<span
											className="text-[#555] cursor-pointer transition hover:text-[#777] text-sm"
											onClick={() => {
												setAmount(
													selectedBsv20?.lim && selectedBsv20.lim !== "0"
														? selectedBsv20.lim
														: selectedBsv20.max,
												);
											}}
										>
											Max:{" "}
											{selectedBsv20?.lim && selectedBsv20.lim !== "0"
												? selectedBsv20.lim
												: selectedBsv20?.max}
										</span>
									</button>
								)}
							</div>

							<input
								disabled={!!mintError}
								className="text-white w-full rounded p-2"
								type="number"
								min={1}
								max={maxIterations + 1}
								onChange={changeAmount}
								value={amount}
								step={step}
								onFocus={(event) =>
									checkTicker(
										ticker || "",
										selectedActionType === ActionType.Mint,
										event,
									)
								}
							/>
						</label>
					</div>
					<div className="divider">Bulk Minting</div>

					<div>
						<div className="p-2 bg-[#111] my-2 rounded flex items-center justify-between">
							<div>{acquireText}</div>
							<input
								type="checkbox"
								className="toggle"
								checked={bulkEnabled}
								disabled={!canEnableBulk}
								onClick={() => {
									if (bulkEnabled) {
										setIterations(1);
									}
									setBulkEnabled(!bulkEnabled);
								}}
							/>
						</div>

						{bulkEnabled && (
							<label className="block mb-4">
								<div className="my-2 flex justify-between items-center">
									<div className="font-mono text-primary/50">{iterations}𝒙</div>
									<div
										className="tooltip opacity-75 text-purple-400 font-mono flex items-center"
										data-tip={`Tier ${currentTier}/5`}
									>
										{stars}
										<div className="mx-1" />
										{bulkMintingTicker}
									</div>
								</div>
								<input
									onChange={changeIterations}
									value={iterations}
									max={maxIterations + step}
									type="range"
									min={1}
									className="range"
									step={maxIterations / step}
								/>
								<div className="w-full flex justify-between text-xs px-2 text-primary/25">
									{spacers}
								</div>
							</label>
						)}
						{/* TODO: Display accurately at end of supply */}
						{bulkEnabled && amount && ticker && (
							<>
								<div className="bg-[#111] text-[#555] rounded p-2 font-mono text-sm">
									<div className="flex items-center justify-between">
										<div className="w-1/2">Bulk Indexing Fee:</div>
										<div className="w-1/2 text-right">${iterationFeeUsd}</div>
									</div>
									<div className="flex items-center justify-between">
										<div className="w-1/2">Est Network Fee:</div>
										<div className="w-1/2 text-right">${networkFeeUsd}</div>
									</div>

									<div className="flex items-center justify-between">
										<div className="w-1/2">
											You will recieve
											<span
												className="tooltip text-warning"
												data-tip={
													!inSync.value && indexers.value && chainInfo.value
														? "The index is not caught up. These tokens may have already been minted."
														: selectedBsv20?.included
														  ? "Mints will be processed in the order they are assembled into blocks. We cannot gaurantee all tokens will be credited."
														  : `This ticker is not included in the index${
																	selectedBsv20?.pendingOps &&
																	selectedBsv20.pendingOps > 0
																		? ` and has ${selectedBsv20.pendingOps} operations in line ahead of this mint`
																		: ""
															  }. These tokens may have already been minted.`
												}
											>
												<FaInfoCircle className="ml-2" />
											</span>
										</div>
										<div className="w-1/2 text-right">
											{(totalTokens > newSupply
												? newSupply
												: totalTokens
											).toLocaleString()}{" "}
											{ticker.toUpperCase()}
										</div>
									</div>
									<div className="flex items-center justify-between">
										<div className="w-1/2">New Supply</div>
										<div className="w-1/2 text-right">
											{newSupply} / {selectedBsv20?.max}
										</div>
									</div>
								</div>
							</>
						)}
						{selectedBsv20 && !selectedBsv20?.included && (
							<>
								<div className="divider">Ticker Status</div>
								<div className="p-2 bg-[#111] my-2 rounded text-warning font-mono">
									<Link href={`/market/bsv20/${selectedBsv20?.tick}`}>
										<FaExclamationCircle className="w-5 h-5 mr-2 inline-flex opacity-50 mb-1" />
										{selectedBsv20?.tick} is not live. Minted supply may be
										inaccurate. Fund {selectedBsv20?.tick} first to be sure you
										aren&apos;t over-minting. There is no gaurentee you will
										recieve valid tokens in this state!
									</Link>
								</div>
							</>
						)}
					</div>
				</React.Fragment>
			)}

			{selectedActionType === ActionType.Deploy && (
				<div className="my-2">
					<label className="block mb-4">
						<div className="flex items-center justify-between my-2">
							Limit Per Mint <span className="text-[#555]">Optional</span>
						</div>
						<input
							className="text-white w-full rounded p-2"
							type="string"
							value={limit}
							pattern="^\S+$"
							onKeyDown={(event) => {
								if (event.key === " " || event.key === "Enter") {
									event.preventDefault();
								}
							}}
							onChange={changeLimit}
						/>
					</label>
				</div>
			)}

			{selectedActionType === ActionType.Deploy && !showOptionalFields && (
				<div
					className="my-2 flex items-center justify-end cursor-pointer text-blue-500 hover:text-blue-400 transition"
					onClick={toggleOptionalFields}
				>
					<RiSettings2Fill className="mr-2" /> More Options
				</div>
			)}

			{selectedActionType === ActionType.Deploy && showOptionalFields && (
				<>
					<div className="my-2">
						<label className="block mb-4">
							<div className="my-2 flex items-center justify-between">
								Decimal Precision
							</div>
							<input
								className="text-white w-full rounded p-2"
								type="number"
								min={0}
								max={18}
								value={decimals}
								placeholder={defaultDec.toString()}
								onChange={changeDecimals}
							/>
						</label>
					</div>
				</>
			)}
			{selectedActionType === ActionType.Deploy && (
				<div className="my-2 flex items-center justify-between mb-4 rounded p-2 text-info-content bg-info">
					<label className="block w-full">
						While BSV20 deployements themselves are indexed immediately, mints
						against them are indexed once an initial listing fee is paid. This
						helps bring minting incentives in line with BSVs insanely low
						network fees, and keeps this survice running reliably. The Listing
						Fee for this deployent will be ${`${listingFee}`}. This can be paid
						later.
					</label>
				</div>
			)}
			{preview && <hr className="my-2 h-2 border-0 bg-[#222]" />}
			<button
				disabled={submitDisabled}
				type="submit"
				onClick={bulkEnabled && iterations > 1 ? bulkInscribe : clickInscribe}
				className="w-full disabled:bg-[#222] disabled:text-[#555] hover:bg-yellow-500 transition bg-yellow-600 enabled:cursor-pointer p-3 text-xl rounded my-4 text-white"
			>
				Preview{" "}
				{selectedActionType === ActionType.Deploy ? "Deployment" : "Mint"}
			</button>
		</div>
	);
};

export default InscribeBsv20;

const maxMaxSupply = BigInt("18446744073709551615");

export const minFee = 100000000; // 1BSV
export const baseFee = 50;

const defaultDec = 8;
const bulkMintingTicker = "EGG";
const bulkMintingTickerMaxSupply = 21000000;
export const iterationFee = 1000;

const calculateTier = (balance: number, bulkMintingTickerMaxSupply: number) => {
	if (balance <= 0) return 0;

	// Calculate balance as a percentage of max supply
	const balancePct = (balance * 100) / bulkMintingTickerMaxSupply; // As percentage

	// Define tier thresholds as percentages of max supply
	// Assuming tiers are at 0.05%, 0.1%, 0.5%, 1%, 5% of max supply

	console.log({ balancePct, tierThresholds });

	// Find the tier based on the percentage thresholds
	for (let tier = 5; tier > 0; tier--) {
		if (balancePct >= tierThresholds[tier - 1]) return tier;
	}
	return tierThresholds.length;
};

// Returns the tier number 1-5
const tierMaxNum = (balance: number) => {
	return calculateTier(balance, bulkMintingTickerMaxSupply);
};

const calculateSpacers = (maxIterations: number, steps: number) => {
	console.log({ maxIterations, steps });
	// Calculate the number of spacers
	// const numSpacers = Math.floor(maxIterations / step);

	// Create an array of spacers
	return Array.from({ length: steps }, (_, index) => {
		return (
			<span key={`spacer-${index + 1}`} className="pointer-events-none">
				|
			</span>
		);
	}).slice(0, 10); // max out at 10 marks for display purposes
};

const bytesPerIteration = 40;

const tierThresholds = [
	0.001, // Tier 1
	0.01, // Tier 2
	0.025, // Tier 3
	0.05, // Tier 4
	0.1, // Tier 5
];
